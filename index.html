<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Cyberpunk Yaşayan Şehir</title>
  <!-- CSS en son ekleyeceğiz -->
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <!-- Yıldızlar için canvas -->
  <canvas id="stars"></canvas>
  <!-- Şehir ve gemiler için canvas -->
  <canvas id="city"></canvas>
  <!-- İmleç ışığı -->
  <div id="cursor-light"></div>

  <script>
    // --- Boyut ve resize ---
    let w = window.innerWidth, h = window.innerHeight;
    const starsCanvas = document.getElementById('stars'), sCtx = starsCanvas.getContext('2d');
    const cityCanvas  = document.getElementById('city'),  cCtx = cityCanvas.getContext('2d');
    const cursor      = document.getElementById('cursor-light');

    function resizeAll() {
      w = window.innerWidth; h = window.innerHeight;
      starsCanvas.width = cityCanvas.width = w;
      starsCanvas.height = cityCanvas.height = h;
      initStars(); initBuildings(); initShips();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    // --- İmleç takip (easing + pulse) ---
    let targetX = w/2, targetY = h/2;
    let currentX = targetX, currentY = targetY;
    const ease = 0.15;

    function onPointerMove(x, y) {
      targetX = x; targetY = y;
      cursor.classList.add('active');
      clearTimeout(cursor._pulseTimeout);
      cursor._pulseTimeout = setTimeout(() => {
        cursor.classList.remove('active');
      }, 200);
    }

    window.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
    window.addEventListener('touchmove', e => {
      const t = e.touches[0]; onPointerMove(t.clientX, t.clientY);
    }, { passive: true });

    function animateCursor() {
      const dx = targetX - currentX;
      const dy = targetY - currentY;
      currentX += dx * ease;
      currentY += dy * ease;
      const scale = cursor.classList.contains('active') ? 1.8 : 1;
      cursor.style.transform = `translate(${currentX}px, ${currentY}px) scale(${scale})`;
      requestAnimationFrame(animateCursor);
    }
    animateCursor();

    window.addEventListener('mouseout', () => { cursor.style.opacity = 0; });
    window.addEventListener('mouseover', () => { cursor.style.opacity = 1; });

    // --- Stars (aynı önceki) ---
    let stars = [];
    function initStars() {
      stars = [];
      for (let i = 0; i < 150; i++) {
        stars.push({ x: Math.random()*w, y: Math.random()*h, r: Math.random()*1.5, a: Math.random(), d: 0.004 + Math.random()*0.02 });
      }
    }
    function drawStars() {
      sCtx.clearRect(0, 0, w, h);
      stars.forEach(s => {
        s.a += s.d; if (s.a <= 0 || s.a >= 1) s.d *= -1;
        sCtx.beginPath(); sCtx.arc(s.x, s.y, s.r, 0, 2*Math.PI);
        sCtx.fillStyle = `rgba(245,230,204,${s.a})`;
        sCtx.fill();
      });
      requestAnimationFrame(drawStars);
    }
    drawStars();

   // --- Buildings (Geliştirilmiş) ---
class Building {
  constructor(x, width, height) {
    this.x = x;
    this.width = width;
    this.height = height;
    this.windows = [];

    // Pencere ızgarası: kolon ve satır sayısı
    const cols = Math.max(3, Math.floor(width / 20));
    const rows = Math.max(4, Math.floor(height / 30));

    // Pencere pozisyonlarını ve başlangıç durumlarını hesapla
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const px = x + (c + 0.5) * (width / cols);
        const py = h - (r + 0.5) * (height / rows) - 10;
        // Başlangıçta %25 ihtimalle açık sarı ışık
        const isOn = Math.random() < 0.25;
        this.windows.push({ x: px, y: py, r: 5, alpha: isOn ? 1 : 0 });
      }
    }
  }

  draw(ctx) {
    // Bina gövdesi
    ctx.fillStyle   = 'rgba(34,0,34,0.9)';
    ctx.strokeStyle = '#8a54ff';
    ctx.lineWidth   = 2;
    ctx.fillRect(this.x, h - this.height, this.width, this.height);
    ctx.strokeRect(this.x, h - this.height, this.width, this.height);

    // Pencereler
    this.windows.forEach(win => {
      if (win.alpha <= 0) return;
      const glow = `rgba(255,217,0,${win.alpha})`;
      ctx.save();
      ctx.beginPath();
      ctx.arc(win.x, win.y, win.r, 0, Math.PI * 2);
      ctx.fillStyle = glow;
      ctx.shadowColor = glow;
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.restore();
    });
  }

  flicker() {
    // Rastgele bir pencerenin ışığını toggle et
    const idx = Math.floor(Math.random() * this.windows.length);
    const w = this.windows[idx];
    w.alpha = w.alpha > 0 ? 0 : 1;
  }
}

let buildings = [];

function initBuildings() {
  buildings = [];
  const count = Math.ceil(w / 120);
  for (let i = 0; i < count; i++) {
    const bw = 60 + Math.random() * 80;
    const bh = 100 + Math.random() * (h * 0.5);
    const bx = i * (w / count) + (Math.random() * 40 - 20);
    buildings.push(new Building(bx, bw, bh));
  }
}

function drawBuildings() {
  cCtx.clearRect(0, 0, w, h);
  buildings.forEach(b => b.draw(cCtx));
  requestAnimationFrame(drawBuildings);
}

// Işık titremesi
setInterval(() => {
  if (buildings.length) {
    buildings[Math.floor(Math.random() * buildings.length)].flicker();
  }
}, 200);

// Başlat
initBuildings();
drawBuildings();


    // --- Ships ---
    class Ship {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = -50;
        this.y = Math.random()*h*0.5 + 50;
        this.vx = 2 + Math.random()*3;
        this.color = ['cyan','magenta','yellow','white'][Math.floor(Math.random()*4)];
        this.size  = 20 + Math.random()*30;
        this.type  = Math.floor(Math.random()*3);
      }
      update() {
        this.x += this.vx;
        if (this.x > w + 50) this.reset();
      }
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = 0.8;
        if (this.type === 0) {
          ctx.beginPath();
          ctx.arc(0,0,this.size*0.6,0,2*Math.PI);
          ctx.fill();
        } else if (this.type === 1) {
          ctx.beginPath();
          ctx.moveTo(-this.size, this.size/2);
          ctx.lineTo( this.size, 0);
          ctx.lineTo(-this.size,-this.size/2);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillRect(-this.size*0.5, -this.size*0.3, this.size, this.size*0.6);
        }
        ctx.restore();
      }
    }

    let ships = [];
    function initShips() {
      ships = [];
      for (let i = 0; i < 5; i++) ships.push(new Ship());
    }
    function drawShips() {
      ships.forEach(s => { s.update(); s.draw(cCtx); });
      requestAnimationFrame(drawShips);
    }
    initShips(); drawShips();

  </script>
</body>
</html>
