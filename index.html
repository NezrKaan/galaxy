<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cyberpunk Neon Şehir - Canlı Dijital Sanat</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #1a0033;
    font-family: 'Orbitron', monospace;
  }
  #info {
    position: fixed;
    top: 10px; left: 10px;
    color: #f5e6cc;
    z-index: 10;
    background: rgba(30,0,70,0.6);
    padding: 8px 15px;
    border-radius: 8px;
    user-select:none;
  }
  @media(max-width:600px){
    #info {
      font-size: 0.8rem;
      padding: 6px 10px;
    }
  }
</style>
</head>
<body>

<div id="info">Cyberpunk Neon Şehir — Fare veya Dokunmatik Hareketi ile Keşfet</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
// --- Temel Setup ---
const scene = new THREE.Scene();

// Kamera
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
camera.position.set(0, 30, 50);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x1a0033);
document.body.appendChild(renderer.domElement);

// Kontroller (Fare ile gezinti)
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.1;
controls.minDistance = 20;
controls.maxDistance = 100;
controls.maxPolarAngle = Math.PI/2 - 0.05;

// --- Neon Renk Paleti ---
const neonColors = [0xff00ff, 0x8a54ff, 0xbb88ff, 0x661177, 0xdd55ff];

// --- Zemin ---
const groundGeo = new THREE.PlaneGeometry(100, 100);
const groundMat = new THREE.MeshBasicMaterial({color: 0x220044});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// --- Basit Binalar ---
const buildings = [];
const buildingGeo = new THREE.BoxGeometry(4, 10, 4);

for(let i = -10; i <= 10; i+=5){
  for(let j = -10; j <= 10; j+=5){
    const height = 5 + Math.random()*20;
    const geo = new THREE.BoxGeometry(4, height, 4);
    const colorIndex = Math.floor(Math.random()*neonColors.length);
    const mat = new THREE.MeshStandardMaterial({
      color: neonColors[colorIndex],
      emissive: neonColors[colorIndex],
      emissiveIntensity: 0.7,
      roughness: 0.1,
      metalness: 0.9,
    });
    const building = new THREE.Mesh(geo, mat);
    building.position.set(i, height/2, j);
    scene.add(building);
    buildings.push(building);
  }
}

// --- Neon Işıklar (PointLight) ---
const neonLights = [];

for(let i=0; i<10; i++){
  const light = new THREE.PointLight(neonColors[i % neonColors.length], 1, 15);
  light.position.set(
    (Math.random()*20)-10,
    5 + Math.random()*20,
    (Math.random()*20)-10
  );
  scene.add(light);
  neonLights.push(light);
}

// --- Sis Efekti ---
const fogColor = new THREE.Color(0x1a0033);
scene.fog = new THREE.FogExp2(fogColor, 0.035);

// --- Atmosferik Partiküller (Toz veya yağmur efekti) ---
const particleCount = 3000;
const particlesGeo = new THREE.BufferGeometry();
const positions = [];

for(let i=0; i<particleCount; i++){
  positions.push(
    (Math.random()-0.5)*100,
    Math.random()*50,
    (Math.random()-0.5)*100
  );
}

particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

const particlesMat = new THREE.PointsMaterial({
  color: 0xbb88ff,
  size: 0.1,
  transparent: true,
  opacity: 0.2,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const particles = new THREE.Points(particlesGeo, particlesMat);
scene.add(particles);

// --- Animasyon Döngüsü ---
function animate(time = 0){
  requestAnimationFrame(animate);

  // Binaları hafif yukarı aşağı titreştir
  buildings.forEach((bld, i) => {
    bld.position.y = (bld.geometry.parameters.height / 2) + Math.sin(time*0.001 + i) * 0.5;
  });

  // Işıkları hafif hareket ettir
  neonLights.forEach((light, i) => {
    light.position.x += Math.sin(time*0.001 + i) * 0.01;
    light.position.z += Math.cos(time*0.001 + i) * 0.01;
  });

  // Partikülleri aşağı doğru kaydır ve tekrar yukarı gönder (yağmur/yağmur benzeri)
  const positions = particles.geometry.attributes.position.array;
  for(let i=1; i<positions.length; i+=3){
    positions[i] -= 0.05;
    if(positions[i] < 0) positions[i] = 50;
  }
  particles.geometry.attributes.position.needsUpdate = true;

  controls.update();
  renderer.render(scene, camera);
}

animate();

// --- Responsive ---
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
