<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Cyberpunk Yaşayan Şehir</title>
    <link rel="stylesheet" href="./styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Electrolize&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="stars"></canvas>
    <canvas id="city"></canvas>
    <div id="cursor-light"></div>

    <script>
        // Canvas ve Context'ler
        let w = window.innerWidth, h = window.innerHeight;
        const starsCanvas = document.getElementById('stars');
        const sCtx = starsCanvas.getContext('2d');
        const cityCanvas = document.getElementById('city');
        const cCtx = cityCanvas.getContext('2d');
        const cursor = document.getElementById('cursor-light');

        // --- Boyutlandırma ve Yeniden Boyutlandırma ---
        function resizeAll() {
            w = window.innerWidth;
            h = window.innerHeight;
            starsCanvas.width = w;
            starsCanvas.height = h;
            cityCanvas.width = w;
            cityCanvas.height = h;
            initStars();
            // initBuildings ve initShips fonksiyonlarını burada tekrar çağırmak,
            // ekran boyutu değiştiğinde binaların ve gemilerin konumlarının
            // doğru yeniden hesaplanmasını sağlar.
            initBuildings();
            initShips();
        }

        window.addEventListener('resize', resizeAll);
        resizeAll(); // Sayfa yüklendiğinde ilk boyutlandırma

        // --- İmleç Takip (Easing ve Darbe Efekti) ---
        let targetX = w / 2, targetY = h / 2;
        let currentX = targetX, currentY = targetY;
        const ease = 0.15; // Yumuşatma faktörü

        function onPointerMove(x, y) {
            targetX = x;
            targetY = y;
            cursor.classList.add('active');
            clearTimeout(cursor._pulseTimeout);
            cursor._pulseTimeout = setTimeout(() => {
                cursor.classList.remove('active');
            }, 200); // 200ms sonra 'active' sınıfını kaldır
        }

        // Mouse ve dokunmatik olay dinleyicileri
        window.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            if (e.touches.length > 0) {
                const t = e.touches[0];
                onPointerMove(t.clientX, t.clientY);
            }
        }, { passive: true }); // Dokunmatik olaylarda pasif dinleyici

        function animateCursor() {
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            currentX += dx * ease;
            currentY += dy * ease;

            const scale = cursor.classList.contains('active') ? 1.8 : 1;
            cursor.style.transform = `translate3d(${currentX}px, ${currentY}px, 0) scale(${scale})`;
            requestAnimationFrame(animateCursor);
        }
        animateCursor(); // İmleç animasyonunu başlat

        window.addEventListener('mouseout', () => { cursor.style.opacity = 0; });
        window.addEventListener('mouseover', () => { cursor.style.opacity = 1; });

        // --- Yıldızlar ---
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h,
                    r: Math.random() * 1.8,
                    a: Math.random(),
                    d: (Math.random() * 0.01 + 0.002) * (Math.random() > 0.5 ? 1 : -1)
                });
            }
        }

        function drawStars() {
            sCtx.clearRect(0, 0, w, h);
            stars.forEach(s => {
                s.a += s.d;
                if (s.a <= 0.1 || s.a >= 0.9) s.d *= -1;
                sCtx.beginPath();
                sCtx.arc(s.x, s.y, s.r, 0, 2 * Math.PI);
                sCtx.fillStyle = `rgba(245,230,204,${s.a})`;
                sCtx.fill();
            });
            requestAnimationFrame(drawStars);
        }
        // initStars() ve drawStars() resizeAll içinde zaten çağrılıyor.
        // Ancak ilk yüklemede çağrılmalarını garanti altına alalım.
        // (resizeAll() zaten çağırıyor ama manuel çağrı da işe yarar)

        // --- Binalar (Geliştirilmiş ve Gerçekçi) ---
        class Building {
            constructor(x, width, height, baseHue) {
                this.x = x;
                this.width = width;
                this.height = height;
                this.windows = [];
                this.baseHue = baseHue;
                this.details = [];

                const cols = Math.max(4, Math.floor(width / 15));
                const rows = Math.max(6, Math.floor(height / 20));

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const winWidth = width / cols * 0.6;
                        const winHeight = height / rows * 0.7;
                        const px = this.x + (c * (width / cols)) + (width / cols - winWidth) / 2;
                        const py = h - this.height + (r * (height / rows)) + (height / rows - winHeight) / 2;

                        const isOn = Math.random() < 0.35;
                        this.windows.push({
                            x: px, y: py, width: winWidth, height: winHeight,
                            alpha: isOn ? (0.7 + Math.random() * 0.3) : 0,
                            color: `hsl(${this.baseHue + (Math.random() * 30 - 15)}, 100%, 70%)`,
                            flickerRate: 0.05 + Math.random() * 0.1
                        });
                    }
                }
                this.generateDetails();
            }

            generateDetails() {
                if (Math.random() < 0.6) {
                    this.details.push({
                        type: 'antenna',
                        x: this.x + this.width / 2,
                        y: h - this.height - (10 + Math.random() * 30),
                        length: 20 + Math.random() * 50,
                        color: `hsl(${this.baseHue}, 50%, 40%)`
                    });
                }
                if (Math.random() < 0.4) {
                    this.details.push({
                        type: 'sign',
                        x: this.x + this.width / 2 + (Math.random() * this.width / 4 - this.width / 8),
                        y: h - this.height + (Math.random() * this.height * 0.4),
                        text: ['NEON', 'CYBER', 'GLOW', 'TECH'][Math.floor(Math.random() * 4)],
                        color: `hsl(${(this.baseHue + 180) % 360}, 100%, 60%)`
                    });
                }
            }

            draw(ctx) {
                const gradient = ctx.createLinearGradient(this.x, h - this.height, this.x, h);
                gradient.addColorStop(0, `hsla(${this.baseHue}, 50%, 15%, 0.95)`);
                gradient.addColorStop(1, `hsla(${this.baseHue}, 60%, 5%, 0.98)`);
                ctx.fillStyle = gradient;
                ctx.strokeStyle = `hsl(${this.baseHue}, 70%, 40%)`;
                ctx.lineWidth = 1.5;
                ctx.fillRect(this.x, h - this.height, this.width, this.height);
                ctx.strokeRect(this.x, h - this.height, this.width, this.height);

                this.windows.forEach(win => {
                    if (win.alpha <= 0.05) return;

                    ctx.fillStyle = `rgba(10, 0, 10, 0.2)`;
                    ctx.fillRect(win.x, win.y, win.width, win.height);

                    const glowColor = win.color;
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(win.x, win.y, win.width, win.height);
                    ctx.fillStyle = `hsla(${win.color.match(/\d+/)[0]}, 100%, 70%, ${win.alpha})`;
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 8 + win.alpha * 5;
                    ctx.fill();
                    ctx.restore();
                });

                this.details.forEach(detail => {
                    if (detail.type === 'antenna') {
                        ctx.beginPath();
                        ctx.moveTo(detail.x, h - this.height);
                        ctx.lineTo(detail.x, detail.y);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = detail.color;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(detail.x, detail.y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = 'red';
                        ctx.shadowColor = 'red';
                        ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else if (detail.type === 'sign') {
                        ctx.save();
                        // Font boyutu için min/max kontrolü
                        const fontSize = Math.min(20, this.width * 0.2); // Bina genişliğine göre ayarla
                        ctx.font = `${fontSize}px 'Electrolize', sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.fillStyle = detail.color;
                        ctx.shadowColor = detail.color;
                        ctx.shadowBlur = 15;
                        ctx.fillText(detail.text, detail.x, detail.y);
                        ctx.restore();
                    }
                });
            }

            flicker() {
                const idx = Math.floor(Math.random() * this.windows.length);
                const w = this.windows[idx];
                w.alpha = w.alpha > 0.1 ? 0 : (0.7 + Math.random() * 0.3);
            }

            updateWindows() {
                this.windows.forEach(w => {
                    if (Math.random() < w.flickerRate) {
                        w.alpha = w.alpha > 0.1 ? 0 : (0.7 + Math.random() * 0.3);
                    }
                });
            }
        }

        let buildings = [];

        function initBuildings() {
            buildings = [];
            const minBuildingWidth = 80;
            const maxBuildingWidth = 150;
            let currentX = 0;

            while (currentX < w) {
                const bw = minBuildingWidth + Math.random() * (maxBuildingWidth - minBuildingWidth);
                const bh = h * (0.3 + Math.random() * 0.5);
                const bx = currentX + (Math.random() * 30 - 15);
                const baseHue = Math.floor(Math.random() * 360);
                buildings.push(new Building(bx, bw, bh, baseHue));
                currentX += bw - 20;
            }
            buildings.sort((a, b) => a.height - b.height); // Yüksekliğe göre sırala
        }

        function drawBuildings() {
            cCtx.clearRect(0, 0, w, h);
            buildings.forEach(b => {
                b.draw(cCtx);
                b.updateWindows();
            });
            requestAnimationFrame(drawBuildings);
        }

        // Binaları başlat
        // initBuildings() ve drawBuildings() zaten resizeAll içinde çağrılıyor.
        // Ancak ilk yüklemede çağrılmalarını garanti altına alalım.

        // --- Gemiler (Daha çeşitli ve detaylı) ---
        class Ship {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = -Math.random() * w * 0.5 - 100;
                this.y = h * (0.1 + Math.random() * 0.4);
                this.vx = 1.5 + Math.random() * 2.5;
                this.vy = (Math.random() * 0.5 - 0.25);
                this.size = 25 + Math.random() * 40;
                this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                this.type = Math.floor(Math.random() * 4);
                this.hasTrail = Math.random() < 0.7;
                this.trailPoints = [];
                this.lightPulse = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;

                this.y += Math.sin(this.x * 0.02) * 0.5;

                if (this.x > w + this.size + 100) this.reset();

                if (this.hasTrail) {
                    this.trailPoints.push({ x: this.x, y: this.y, alpha: 1 });
                    if (this.trailPoints.length > 30) {
                        this.trailPoints.shift();
                    }
                    this.trailPoints.forEach(p => p.alpha *= 0.95);
                }

                this.lightPulse += 0.1;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.hasTrail && this.trailPoints.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trailPoints[0].x - this.x, this.trailPoints[0].y - this.y);
                    for (let i = 1; i < this.trailPoints.length; i++) {
                        ctx.lineTo(this.trailPoints[i].x - this.x, this.trailPoints[i].y - this.y);
                    }
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = 0.6;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }

                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.9;

                if (this.type === 0) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size, this.size / 2);
                    ctx.lineTo(this.size, 0);
                    ctx.lineTo(-this.size, -this.size / 2);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 1) {
                    ctx.fillRect(-this.size * 0.6, -this.size * 0.2, this.size * 1.2, this.size * 0.4);
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.4, -this.size * 0.5);
                    ctx.lineTo(-this.size * 0.2, -this.size * 0.2);
                    ctx.lineTo(this.size * 0.4, -this.size * 0.2);
                    ctx.lineTo(this.size * 0.2, -this.size * 0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 2) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size, 0);
                    ctx.bezierCurveTo(-this.size * 0.5, -this.size * 0.8, this.size * 0.5, -this.size * 0.8, this.size, 0);
                    ctx.bezierCurveTo(this.size * 0.5, this.size * 0.8, -this.size * 0.5, this.size * 0.8, -this.size, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }

                const lightRadius = 5 + Math.sin(this.lightPulse) * 3;
                ctx.beginPath();
                ctx.arc(this.size * 0.8, 0, lightRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.shadowColor = 'cyan';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.restore();
            }
        }

        let ships = [];
        function initShips() {
            ships = [];
            for (let i = 0; i < 7; i++) ships.push(new Ship());
        }
        function drawShips() {
            

            ships.forEach(s => { s.update(); s.draw(cCtx); });
            requestAnimationFrame(drawShips);
        }
    
        drawStars();
        drawBuildings();
        drawShips();

    </script>
</body>
</html>
